/**
 * QTI (Question & Test Interoperability) Service
 *
 * QTI 2.1 STANDARD:
 * - XML-based format for quiz interchange
 * - Compatible with Canvas, Blackboard, Moodle
 * - Must follow specific schema
 *
 * Canvas QTI Requirements:
 * - QTI 2.1 format
 * - ZIP package with manifest (imsmanifest.xml)
 * - Questions in assessment/*.xml files
 */

import archiver from 'archiver';
import fs from 'fs/promises';
import { createWriteStream } from 'fs';
import path from 'path';
import type { QuizQuestion } from '@quizflow/types';
import { AppError } from '@/middleware/errorHandler.js';
import { logger } from '@/config/logger.js';

interface QTIOptions {
  title: string;
  questions: QuizQuestion[];
  hasWatermark?: boolean;
}

/**
 * Generate QTI package and return path
 */
export const generateQTIPackage = async (
  options: QTIOptions
): Promise<string> => {
  const { title, questions, hasWatermark } = options;

  try {
    // Create temp directory for QTI files
    const tempDir = path.join('temp', `qti_${Date.now()}`);
    await fs.mkdir(tempDir, { recursive: true });

    const identifier = `assessment_${Date.now()}`;

    // Generate manifest
    const manifest = generateManifest(title, questions.length, identifier);
    await fs.writeFile(path.join(tempDir, 'imsmanifest.xml'), manifest);

    // Create non_cc_assessments directory (Canvas requirement)
    const assessmentDir = path.join(tempDir, 'non_cc_assessments');
    await fs.mkdir(assessmentDir, { recursive: true });

    // Generate assessment XML
    const assessment = generateAssessmentXML(title, questions, hasWatermark, identifier);
    await fs.writeFile(
      path.join(assessmentDir, `${identifier}.xml.qti`),
      assessment
    );

    // Generate assessment metadata
    const metadata = generateAssessmentMeta(title, identifier, questions.length);
    await fs.writeFile(
      path.join(assessmentDir, `${identifier}.xml`),
      metadata
    );

    // Create ZIP package
    const outputDir = 'uploads/qti';
    await fs.mkdir(outputDir, { recursive: true });

    const zipFileName = `quiz_${Date.now()}.zip`;
    const zipPath = path.join(outputDir, zipFileName);

    await createZipArchive(tempDir, zipPath);

    // Clean up temp directory
    await fs.rm(tempDir, { recursive: true, force: true });

    logger.info('QTI package generated', { zipPath });

    return zipPath;
  } catch (error) {
    logger.error('QTI generation failed', error);
    throw new AppError(500, 'Failed to generate QTI package');
  }
};

/**
 * Generate IMS Manifest (required for QTI package)
 */
function generateManifest(title: string, questionCount: number, identifier: string): string {
  const manifestId = `manifest_${Date.now()}`;

  return `<?xml version="1.0" encoding="UTF-8"?>
<manifest identifier="${manifestId}"
          xmlns="http://www.imsglobal.org/xsd/imscc/imscp_v1p1"
          xmlns:lom="http://ltsc.ieee.org/xsd/imscc/LOM/resource"
          xmlns:imsmd="http://www.imsglobal.org/xsd/imsmd_v1p2"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://www.imsglobal.org/xsd/imscc/imscp_v1p1 http://www.imsglobal.org/profile/cc/ccv1p1/ccv1p1_imscp_v1p2_v1p0.xsd http://ltsc.ieee.org/xsd/imscc/LOM/resource http://www.imsglobal.org/profile/cc/ccv1p1/LOM/ccv1p1_lomresource_v1p0.xsd http://www.imsglobal.org/xsd/imsmd_v1p2 http://www.imsglobal.org/xsd/imsmd_v1p2p2.xsd">
  <metadata>
    <schema>IMS Common Cartridge</schema>
    <schemaversion>1.1.0</schemaversion>
    <imsmd:lom>
      <imsmd:general>
        <imsmd:title>
          <imsmd:langstring xml:lang="en">${escapeXml(title)}</imsmd:langstring>
        </imsmd:title>
        <imsmd:description>
          <imsmd:langstring xml:lang="en">Quiz with ${questionCount} questions generated by QuizFlow AI</imsmd:langstring>
        </imsmd:description>
      </imsmd:general>
    </imsmd:lom>
  </metadata>
  <organizations/>
  <resources>
    <resource identifier="${identifier}_meta" type="associatedcontent/imscc_xmlv1p1/learning-application-resource" href="${identifier}.xml">
      <file href="non_cc_assessments/${identifier}.xml"/>
    </resource>
    <resource identifier="${identifier}" type="imsqti_xmlv1p2/imscc_xmlv1p1/assessment" href="non_cc_assessments/${identifier}.xml.qti">
      <file href="non_cc_assessments/${identifier}.xml.qti"/>
      <dependency identifierref="${identifier}_meta"/>
    </resource>
  </resources>
</manifest>`;
}

/**
 * Generate Canvas Assessment Metadata XML
 */
function generateAssessmentMeta(title: string, identifier: string, questionCount: number): string {
  return `<?xml version="1.0" encoding="UTF-8"?>
<quiz identifier="${identifier}" xmlns="http://canvas.instructure.com/xsd/cccv1p0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://canvas.instructure.com/xsd/cccv1p0 https://canvas.instructure.com/xsd/cccv1p0.xsd">
  <title>${escapeXml(title)}</title>
  <description></description>
  <shuffle_answers>false</shuffle_answers>
  <scoring_policy>keep_highest</scoring_policy>
  <quiz_type>assignment</quiz_type>
  <points_possible>${questionCount}</points_possible>
  <allowed_attempts>1</allowed_attempts>
  <assignment identifier="${identifier}_assignment">
    <title>${escapeXml(title)}</title>
    <assignment_group_identifier_ref></assignment_group_identifier_ref>
    <points_possible>${questionCount}</points_possible>
    <grading_type>points</grading_type>
    <submission_types>online_quiz</submission_types>
  </assignment>
</quiz>`;
}

/**
 * Generate QTI 2.1 Assessment XML
 */
function generateAssessmentXML(
  title: string,
  questions: QuizQuestion[],
  hasWatermark: boolean = false,
  identifier: string
): string {
  const watermark = hasWatermark
    ? '\n<!-- Generated by QuizFlow AI - Free Tier -->'
    : '';

  const questionsXML = questions
    .map((q, index) => generateQuestionXML(q, index))
    .join('\n\n');

  return `<?xml version="1.0" encoding="UTF-8"?>
<questestinterop xmlns="http://www.imsglobal.org/xsd/ims_qtiasiv1p2"
                 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                 xsi:schemaLocation="http://www.imsglobal.org/xsd/ims_qtiasiv1p2 http://www.imsglobal.org/xsd/ims_qtiasiv1p2p1.xsd">${watermark}
  <assessment ident="${identifier}" title="${escapeXml(title)}">
    <qtimetadata>
      <qtimetadatafield>
        <fieldlabel>qmd_timelimit</fieldlabel>
        <fieldentry>0</fieldentry>
      </qtimetadatafield>
      <qtimetadatafield>
        <fieldlabel>cc_maxattempts</fieldlabel>
        <fieldentry>1</fieldentry>
      </qtimetadatafield>
    </qtimetadata>
    <section ident="root_section">
      ${questionsXML}
    </section>
  </assessment>
</questestinterop>`;
}

/**
 * Generate single question XML (Multiple Choice)
 */
function generateQuestionXML(
  question: QuizQuestion,
  index: number
): string {
  const questionId = `question_${index + 1}`;
  const responseId = `response_${index + 1}`;

  // Generate response options
  const responses = question.options
    .map((option, optIndex) => {
      const optionId = `option_${optIndex + 1}`;

      return `
      <response_label ident="${optionId}">
        <material>
          <mattext texttype="text/plain">${escapeXml(option)}</mattext>
        </material>
      </response_label>`;
    })
    .join('');

  // Find correct answer index
  const correctIndex = question.options.indexOf(question.correctAnswer);
  const correctId = `option_${correctIndex + 1}`;

  return `
    <item ident="${questionId}" title="Question ${index + 1}">
      <itemmetadata>
        <qtimetadata>
          <qtimetadatafield>
            <fieldlabel>question_type</fieldlabel>
            <fieldentry>multiple_choice_question</fieldentry>
          </qtimetadatafield>
          <qtimetadatafield>
            <fieldlabel>points_possible</fieldlabel>
            <fieldentry>1</fieldentry>
          </qtimetadatafield>
        </qtimetadata>
      </itemmetadata>
      <presentation>
        <material>
          <mattext texttype="text/plain">${escapeXml(question.question)}</mattext>
        </material>
        <response_lid ident="${responseId}" rcardinality="Single">
          <render_choice>${responses}
          </render_choice>
        </response_lid>
      </presentation>
      <resprocessing>
        <outcomes>
          <decvar maxvalue="100" minvalue="0" varname="SCORE" vartype="Decimal"/>
        </outcomes>
        <respcondition continue="No">
          <conditionvar>
            <varequal respident="${responseId}">${correctId}</varequal>
          </conditionvar>
          <setvar action="Set" varname="SCORE">100</setvar>
        </respcondition>
      </resprocessing>
      ${question.explanation ? `<itemfeedback ident="correct_fb">
        <flow_mat>
          <material>
            <mattext texttype="text/plain">${escapeXml(question.explanation)}</mattext>
          </material>
        </flow_mat>
      </itemfeedback>` : ''}
    </item>`;
}

/**
 * Create ZIP archive
 */
function createZipArchive(sourceDir: string, outputPath: string): Promise<void> {
  return new Promise((resolve, reject) => {
    const output = createWriteStream(outputPath);
    const archive = archiver('zip', {
      zlib: { level: 9 }, // Maximum compression
    });

    output.on('close', () => {
      logger.debug('ZIP created', {
        path: outputPath,
        size: archive.pointer(),
      });
      resolve();
    });

    archive.on('error', (err) => {
      reject(err);
    });

    archive.pipe(output);
    archive.directory(sourceDir, false);
    archive.finalize();
  });
}

/**
 * Escape XML special characters
 */
function escapeXml(unsafe: string): string {
  return unsafe
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');
}

