/**
 * QTI (Question & Test Interoperability) Service
 *
 * QTI 2.1 STANDARD:
 * - XML-based format for quiz interchange
 * - Compatible with Canvas, Blackboard, Moodle
 * - Must follow specific schema
 *
 * Canvas QTI Requirements:
 * - QTI 2.1 format
 * - ZIP package with manifest (imsmanifest.xml)
 * - Questions in assessment/*.xml files
 */

import archiver from 'archiver';
import fs from 'fs/promises';
import { createWriteStream } from 'fs';
import path from 'path';
import crypto from 'crypto';
import type { QuizQuestion } from '@quizflow/types';
import { AppError } from '@/middleware/errorHandler.js';
import { logger } from '@/config/logger.js';

interface QTIOptions {
  title: string;
  questions: QuizQuestion[];
  hasWatermark?: boolean;
  filename?: string;
}

/**
 * Generate QTI package and return path
 */
export const generateQTIPackage = async (
  options: QTIOptions
): Promise<string> => {
  const { title, questions, hasWatermark, filename } = options;

  try {
    // Create temp directory for QTI files
    const tempDir = path.join('temp', `qti_${Date.now()}`);
    await fs.mkdir(tempDir, { recursive: true });

    // Generate Canvas-style assessment identifier
    const identifier = generateCanvasId(`${title}_${Date.now()}`);

    // Use custom filename or fallback to title
    const safeFilename = filename || title.replace(/[^a-z0-9]/gi, '_').toLowerCase();

    // Generate assessment XML (single file)
    const assessment = generateAssessmentXML(title, questions, hasWatermark, identifier);
    const xmlFileName = `${safeFilename}.xml`;
    await fs.writeFile(path.join(tempDir, xmlFileName), assessment);

    // Create ZIP package
    const outputDir = 'uploads/qti';
    await fs.mkdir(outputDir, { recursive: true });

    const zipFileName = `${safeFilename}.zip`;
    const zipPath = path.join(outputDir, zipFileName);

    await createZipArchive(tempDir, zipPath);

    // Clean up temp directory
    await fs.rm(tempDir, { recursive: true, force: true });

    logger.info('QTI package generated', { zipPath, filename: safeFilename });

    return zipPath;
  } catch (error) {
    logger.error('QTI generation failed', error);
    throw new AppError(500, 'Failed to generate QTI package');
  }
};

/**
 * Generate QTI 2.1 Assessment XML
 */
function generateAssessmentXML(
  title: string,
  questions: QuizQuestion[],
  hasWatermark: boolean = false,
  identifier: string
): string {
  const watermark = hasWatermark
    ? '\n<!-- Generated by QuizFlow AI - Free Tier -->'
    : '';

  const questionsXML = questions
    .map((q, index) => generateQuestionXML(q, index))
    .join('\n\n');

  return `<?xml version="1.0" encoding="UTF-8"?>
<questestinterop xmlns="http://www.imsglobal.org/xsd/ims_qtiasiv1p2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.imsglobal.org/xsd/ims_qtiasiv1p2 http://www.imsglobal.org/xsd/ims_qtiasiv1p2p1.xsd">${watermark}
<assessment ident="${identifier}" title="${escapeXml(title)}">
<qtimetadata>
<qtimetadatafield>
<fieldlabel>cc_maxattempts</fieldlabel>
<fieldentry>1</fieldentry>
</qtimetadatafield>
</qtimetadata>
<section ident="root_section">
${questionsXML}
</section>
</assessment>
</questestinterop>`;
}

/**
 * Generate single question XML (Multiple Choice)
 */
function generateQuestionXML(
  question: QuizQuestion,
  index: number
): string {
  // Generate Canvas-style hash identifiers
  const questionId = generateCanvasId(`question_${index}_${question.question}`);
  const assessmentQuestionId = generateCanvasId(`assessment_question_${index}_${question.question}`);

  // Generate option IDs and store them
  const optionIds = question.options.map((option, optIndex) =>
    generateCanvasId(`option_${index}_${optIndex}_${option}`)
  );

  // Find correct answer index
  const correctIndex = question.options.indexOf(question.correctAnswer);
  const correctId = optionIds[correctIndex];

  // Generate response options
  const responses = question.options
    .map((option, optIndex) => {
      const optionId = optionIds[optIndex];

      return `
<response_label ident="${optionId}">
<material>
<mattext texttype="text/html">${escapeXml(option)}</mattext>
</material>
</response_label>`;
    })
    .join('');

  return `
<item ident="${questionId}" title="Question">
<itemmetadata>
<qtimetadata>
<qtimetadatafield>
<fieldlabel>question_type</fieldlabel>
<fieldentry>multiple_choice_question</fieldentry>
</qtimetadatafield>
<qtimetadatafield>
<fieldlabel>points_possible</fieldlabel>
<fieldentry>2</fieldentry>
</qtimetadatafield>
<qtimetadatafield>
<fieldlabel>original_answer_ids</fieldlabel>
<fieldentry>${optionIds.join(',')}</fieldentry>
</qtimetadatafield>
<qtimetadatafield>
<fieldlabel>assessment_question_identifierref</fieldlabel>
<fieldentry>${assessmentQuestionId}</fieldentry>
</qtimetadatafield>
</qtimetadata>
</itemmetadata>
<presentation>
<material>
<mattext texttype="text/html">${escapeXml(question.question)}</mattext>
</material>
<response_lid ident="response1" rcardinality="Single">
<render_choice>${responses}
</render_choice>
</response_lid>
</presentation>
<resprocessing>
<outcomes>
<decvar maxvalue="100" minvalue="0" varname="SCORE" vartype="Decimal"/>
</outcomes>
<respcondition continue="No">
<conditionvar>
<varequal respident="response1">${correctId}</varequal>
</conditionvar>
<setvar actoin="Set" varname="SCORE">100</setvar>
</respcondition>
</resprocessing>
</item>`;
}

/**
 * Create ZIP archive
 */
function createZipArchive(sourceDir: string, outputPath: string): Promise<void> {
  return new Promise((resolve, reject) => {
    const output = createWriteStream(outputPath);
    const archive = archiver('zip', {
      zlib: { level: 9 }, // Maximum compression
    });

    output.on('close', () => {
      logger.debug('ZIP created', {
        path: outputPath,
        size: archive.pointer(),
      });
      resolve();
    });

    archive.on('error', (err) => {
      reject(err);
    });

    archive.pipe(output);
    archive.directory(sourceDir, false);
    archive.finalize();
  });
}

/**
 * Escape XML special characters
 */
function escapeXml(unsafe: string): string {
  return unsafe
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');
}

/**
 * Generate Canvas-compatible identifier (SHA-256 hash)
 */
function generateCanvasId(input: string): string {
  return crypto
    .createHash('sha256')
    .update(input + Math.random().toString())
    .digest('hex');
}

